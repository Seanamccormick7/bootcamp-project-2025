<!DOCTYPE html>
<html>
  <head>
    <title>Understanding TypeScript</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../styles.css" />
  </head>
  <body>
    <nav class="navbar">
      <h1 class="logo"><a href="../index.html">personal website</a></h1>
      <ul class="nav-list">
        <li><a href="../index.html">Home</a></li>
        <li><a href="../portfolio.html">Portfolio</a></li>
        <li><a href="../resume.html">Resume</a></li>
        <li><a href="../blog.html">Blog</a></li>
        <li><a href="../contact.html">Contact</a></li>
      </ul>
    </nav>

    <main>
      <h1 class="page-title">Understanding TypeScript</h1>
      <article class="resume" style="max-width: 900px">
        <p class="entry-info">Posted: 10/10/2025</p>
        <img
          src="../images/typescript.jpg"
          alt="TypeScript logo"
          class="blog-image"
        />
        <p>
          TypeScript adds a type system on top of JavaScript so you can catch
          mistakes before your code even runs. With static types, your editor
          can auto-complete smarter, refactor safer, and flag mismatches like
          passing a string where a number is expected. None of this changes how
          the browser executes your app—TypeScript compiles down to plain
          JavaScript—but it changes the developer experience dramatically,
          especially as a codebase grows.
        </p>
        <p>
          The core building blocks are type annotations, interfaces, unions,
          generics, and control-flow type narrowing. You can start small by
          typing function parameters and return values, then graduate to
          modeling domain objects with interfaces, using union types for clear
          intent, and leveraging generics for reusable utilities. Configuration
          lives in <code>tsconfig.json</code>, where options like
          <code>strict</code>, <code>noImplicitAny</code>, and
          <code>target</code> shape how rigorous the compiler is and what
          JavaScript it emits.
        </p>
        <p>
          Adoption works best incrementally. Turn on TypeScript, fix the
          low-hanging errors, and chip away at any <code>any</code> types over
          time. Keep types close to business logic so they stay accurate, and
          avoid over-engineering: not every helper needs an ornate generic. The
          payoff is fewer runtime surprises, clearer contracts between modules,
          and confidence when refactoring—benefits that compound as your project
          and team scale.
        </p>
      </article>
    </main>

    <footer class="footer">© 2025 Sean McCormick | All Rights Reserved</footer>
  </body>
</html>
